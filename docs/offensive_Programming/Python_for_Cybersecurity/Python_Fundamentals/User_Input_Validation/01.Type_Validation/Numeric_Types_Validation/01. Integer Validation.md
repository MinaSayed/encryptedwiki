---
title: Integer Validation
---


## What is integer validation and why do we need it?

In Python programming, we always ask the user to provide information that will be manipulated inside the script.
The problem is that a programmer must never trust the intention of the user. This is one of the most important rules in programming: **do not trust user input**.

The user can enter inputs that cause the program to crash, and attackers can intentionally trigger these crashes to access sensitive information. They force the program to fail by entering invalid inputs.

Because of that, we need to validate user input correctly to avoid such issues. User input validation can be categorized into many types depending on what you want to validate and what you expect the user to enter.

**Integer validation** means being completely sure that the user enters a whole number, not a float, string, or boolean value.

In the real world, hackers often use tools to scan a network for open **ports**.
A port is like a numbered door on a computer. These numbers are always whole numbers (integers), such as 80 or 443.

When you write a script to scan a port, you must make sure the user provides a whole number.
If the user types `"ABC"` instead of `"80"`, the program will crash.

In Python, we use the `input()` function to get data, but it always returns text (a string). We then use `int()` to try to convert that text into a whole number.

---

**For Example:**

If you want to build a basic port scanner, you need to ask the user which port number they want to scan.

```python
target_port = int(input("Enter the port number: "))
```

**Output:**

```text
Enter the port number:
```

The script will wait for the user input. Whatever the user enters will be stored as a string value, so we then try to convert it into an integer using the `int()` method.

After the user enters their input, many cases can happen. In security, we call this **attack surface analysis**.

**Possible cases:**

**Case 1: The user entered a valid port number (0–65535)**

If the user enters a valid value, for example `80`, the `input()` function stores it as a string `"80"`.
Then `int()` successfully converts it into the integer `80` and stores it in the variable `target_port`.

The program runs normally, and no errors occur.

---

**Case 2: The user entered a string value such as `"EIGHTY"`**

If the user enters `"EIGHTY"`, the `input()` function stores it as a string.
When `int()` tries to convert this value, Python cannot convert non-numeric text into an integer.

This will cause a **ValueError**, and the program will crash if the input is not validated.

---

**Case 3: The user entered a negative value such as `-80`**

If the user enters `-80`, `int()` will successfully convert it into an integer because `-80` is still a valid integer value in Python.

However, this value is **invalid in the context of port numbers**, because port numbers cannot be negative.
If this case is not handled, the program logic becomes incorrect even though no exception is raised.

`int(-80)` works in Python because of how the **`int()` function and the integer type** are defined:

1. **`int()` converts strings or numbers into Python integers.**
Python integers (`int`) can be **negative, zero, or positive**. There is no restriction on sign.

2. When you do:

```python
x = int("-80")
```

-Python sees the string `"-80"`
-The `-` sign is part of the numeric literal
-`int()` parses it and produces the integer `-80`

3. From Python’s point of view, `-80` is a **perfectly valid integer**, so no error occurs.

The reason this is important in your context (ports) is that **just because Python allows it
 doesn’t mean it’s semantically valid**. Port numbers cannot be negative in networking,
so you need to check for that **after** converting with `int()`:

```python
if target_port < 0 or target_port > 65535:
    print("Invalid port number!")
```

So, `int(-80)` works because Python’s integers are signed, but `-80` is **invalid for your specific use case**.

**Case 4: The user entered a string with a sign such as `"+80"`**

If the user enters `"+80"`, Python can successfully convert it using `int()` because `+80` is a valid integer representation.

This means no error will occur, and the value will become `80`.
Even though this input works, it should still be considered during validation because it is a user-controlled input.

---

**Case 5: The user entered a port number greater than the maximum allowed value**

If the user enters a number greater than the maximum port value (65535), `int()` will still convert it successfully.

However, this value is **invalid from a networking perspective**, because valid port numbers must be between 0 and 65535.

If this case is not checked, the program may behave incorrectly or attempt operations that make no sense.


**Case 6: The user entered an empty input or only spaces**

If the user presses Enter without typing anything, or enters only spaces, `input()` stores it as an empty string.
Trying to convert it with `int()` will cause a **ValueError**, crashing the program if not handled.

---

**Case 7: The user entered a float value such as `80.5`**

If the user enters `80.5`, `int()` cannot directly convert it unless explicitly cast or rounded.
This will also cause a **ValueError**, and the program will crash without proper validation.

---

**Case 8: The user entered special characters or symbols such as `@80` or `#123`**

Any non-numeric characters combined with numbers will cause `int()` to fail, raising a **ValueError**.
Attackers can use this to test for input vulnerabilities.

---

**Case 9: The user entered a very large number beyond Python’s integer limit** *(rare in Python 3 but theoretically possible if using other systems)*

Python 3 handles arbitrarily large integers, but in some applications or libraries, extremely large numbers may cause overflows or unexpected behavior.
Port numbers beyond 65535 are **invalid** in networking terms, even if Python accepts them as integers.

---

## Types of Integer validation:

In Python programming, validating user input is essential to ensure the program runs safely and correctly.
Depending on what you expect from the user, integer validation can take different forms. Here are the main types:
---

### 1. Validate that the user enters a positive integer (whole number):

#### The checks that we usually include:

This validation ensures that the user provides **non-negative integers only** (0 or greater). In this validation case, we ask the user to enter a positive integer only. Then we will convert the user input into an integer using `int()`, and also verify that the integer is greater than or equal to zero (`>= 0`).

**- Step 1: Ask the user to enter a positive integer value using `input()` method:**

```python
user_input = input("Please enter a positive integer value: ")
```

**- Step 2: Convert the user input into an integer using the `int()` method**

This method will convert the string user input into an integer:

```python
target_value = int(user_input)
```

* **Case 1:** If the value converts successfully, store it in the variable.
* **Case 2:** If the value does not convert successfully, Python will raise an exception. This exception needs to be handled, and the user should be asked again to enter a valid positive integer.

**- Step 3: Ensure that the user value is greater than or equal to zero**

```python
if target_value >= 0:
    print("You entered a positive integer.")
else:
    print("You didn't enter a positive integer.")
```

**- Step 4: Repeat the previous checks using a loop**

We have to continuously recheck the input until the user enters a valid positive integer. This ensures that the program does not crash and only accepts correct input. The general approach:

* Wrap Steps 1–3 in a loop
* Catch exceptions when conversion fails
* Reask the user to enter the value until it passes all checks

```python
while True:
    try:
        user_input = input("Please enter a positive integer value: ")
        target_value = int(user_input)
        if target_value >= 0:
            print("You entered a positive integer.")
            break  # exit the loop once input is valid
        else:
            print("You didn't enter a positive integer. Try again.")
    except ValueError:
        print("Invalid input. Please enter a numeric positive integer.")
```


#### Application of this check:

Used for port numbers, quantities, ages, or any input that cannot be negative.
Ensures invalid negative inputs or non-numeric inputs are rejected, and
the program continues to run safely without crashing.


---

### 2. Validate that the user enters a negative integer

This validation ensures that the user provides **integers less than zero**.

**Checks usually include:**

* Convert the input to an integer using `int()`
* Verify that the integer is less than zero (`< 0`)

**Application of this check:**

Used for error codes, offsets, or cases where only negative numbers are meaningful.

---

**3. Validate that the user enters any integer (positive, negative, or zero) and not a string**

This is the most general type of integer validation. It ensures the input is numeric and can include all integers, regardless of sign.

**Checks usually include:**

* Attempt to convert the input to an integer using `int()`
* Catch `ValueError` exceptions if the conversion fails (for example, if the user enters `"abc"` or `"12.5"`)
* Optionally, check for limits or constraints depending on the application

**Application of this check:**

Used when the program accepts all integers, such as counters, general numeric input, or configuration values. Ensures strings or floats are rejected.

---

**4. Validate that the user enters a non-zero integer**

This validation ensures the user provides an integer that is **not zero**.

**Checks usually include:**

* Convert the input to `int()`
* Verify that `int(input) != 0`

**Application of this check:**

Used for divisors in calculations, configuration offsets, or any scenario where zero is invalid.

---

**5. Validate that the user enters an even or odd integer**

This validation ensures that the integer satisfies a **parity condition**.

**Checks usually include:**

* Convert the input to `int()`
* For even: `int(input) % 2 == 0`
* For odd: `int(input) % 2 != 0`

**Application of this check:**

Used for alternating sequences, even-numbered IDs, or other parity-specific requirements.

---

**6. Validate that the user enters an integer divisible by a step (modular integer)**

This validation ensures the input is a multiple of a specific step or interval.

**Checks usually include:**

* Convert the input to `int()`
* Verify that `int(input) % step == 0`

**Application of this check:**

Used for multiples of 5, even port ranges, or any scenario requiring fixed-step increments.

---

**7. Validate that the user enters a strictly formatted integer (no extra characters)**

This validation ensures the input contains only digits, with an optional leading `+` or `-`.

**Checks usually include:**

* Use a regular expression like `^[+-]?\d+$`
* Convert to `int()` only if it matches

**Application of this check:**

Prevents inputs like `"12abc"`, `"12.0"`, or `" 80 "` from passing validation. Useful for secure input parsing.

---

**8. Validate that the user enters a custom domain integer**

This validation ensures the input is one of a **predefined set of integers**.

**Checks usually include:**

* Convert input to `int()`
* Verify that `int(input) in allowed_values`

**Application of this check:**

Used for menu options, choice numbers, or any input that must match a specific allowed list.
