---
title: Integer Validation
---


## What is integer validation and why do we need it?

In Python programming, we always ask the user to provide information that will be manipulated inside the script.
The problem is that a programmer must never trust the intention of the user. This is one of the most important rules in programming: **do not trust user input**.

The user can enter inputs that cause the program to crash, and attackers can intentionally trigger these crashes to access sensitive information. They force the program to fail by entering invalid inputs.

Because of that, we need to validate user input correctly to avoid such issues. User input validation can be categorized into many types depending on what you want to validate and what you expect the user to enter.

**Integer validation** means being completely sure that the user enters a whole number, not a float, string, or boolean value.

In the real world, hackers often use tools to scan a network for open **ports**.
A port is like a numbered door on a computer. These numbers are always whole numbers (integers), such as 80 or 443.

When you write a script to scan a port, you must make sure the user provides a whole number.
If the user types `"ABC"` instead of `"80"`, the program will crash.

In Python, we use the `input()` function to get data, but it always returns text (a string). We then use `int()` to try to convert that text into a whole number.

---

**For Example:**

If you want to build a basic port scanner, you need to ask the user which port number they want to scan.

```python
target_port = int(input("Enter the port number: "))
```

**Output:**

```text
Enter the port number:
```

The script will wait for the user input. Whatever the user enters will be stored as a string value, so we then try to convert it into an integer using the `int()` method.

After the user enters their input, many cases can happen. In security, we call this **attack surface analysis**.

**Possible cases:**

**Case 1: The user entered a valid port number (0–65535)**

If the user enters a valid value, for example `80`, the `input()` function stores it as a string `"80"`.
Then `int()` successfully converts it into the integer `80` and stores it in the variable `target_port`.

The program runs normally, and no errors occur.

---

**Case 2: The user entered a string value such as `"EIGHTY"`**

If the user enters `"EIGHTY"`, the `input()` function stores it as a string.
When `int()` tries to convert this value, Python cannot convert non-numeric text into an integer.

This will cause a **ValueError**, and the program will crash if the input is not validated.

---

**Case 3: The user entered a negative value such as `-80`**

If the user enters `-80`, `int()` will successfully convert it into an integer because `-80` is still a valid integer value in Python.

However, this value is **invalid in the context of port numbers**, because port numbers cannot be negative.
If this case is not handled, the program logic becomes incorrect even though no exception is raised.

`int(-80)` works in Python because of how the **`int()` function and the integer type** are defined:

1. **`int()` converts strings or numbers into Python integers.**
Python integers (`int`) can be **negative, zero, or positive**. There is no restriction on sign.

2. When you do:

```python
x = int("-80")
```

-Python sees the string `"-80"`
-The `-` sign is part of the numeric literal
-`int()` parses it and produces the integer `-80`

3. From Python’s point of view, `-80` is a **perfectly valid integer**, so no error occurs.

The reason this is important in your context (ports) is that **just because Python allows it
 doesn’t mean it’s semantically valid**. Port numbers cannot be negative in networking,
so you need to check for that **after** converting with `int()`:

```python
if target_port < 0 or target_port > 65535:
    print("Invalid port number!")
```

So, `int(-80)` works because Python’s integers are signed, but `-80` is **invalid for your specific use case**.

**Case 4: The user entered a string with a sign such as `"+80"`**

If the user enters `"+80"`, Python can successfully convert it using `int()` because `+80` is a valid integer representation.

This means no error will occur, and the value will become `80`.
Even though this input works, it should still be considered during validation because it is a user-controlled input.

---

**Case 5: The user entered a port number greater than the maximum allowed value**

If the user enters a number greater than the maximum port value (65535), `int()` will still convert it successfully.

However, this value is **invalid from a networking perspective**, because valid port numbers must be between 0 and 65535.

If this case is not checked, the program may behave incorrectly or attempt operations that make no sense.


**Case 6: The user entered an empty input or only spaces**

If the user presses Enter without typing anything, or enters only spaces, `input()` stores it as an empty string.
Trying to convert it with `int()` will cause a **ValueError**, crashing the program if not handled.

---

**Case 7: The user entered a float value such as `80.5`**

If the user enters `80.5`, `int()` cannot directly convert it unless explicitly cast or rounded.
This will also cause a **ValueError**, and the program will crash without proper validation.

---

**Case 8: The user entered special characters or symbols such as `@80` or `#123`**

Any non-numeric characters combined with numbers will cause `int()` to fail, raising a **ValueError**.
Attackers can use this to test for input vulnerabilities.

---

**Case 9: The user entered a very large number beyond Python’s integer limit** *(rare in Python 3 but theoretically possible if using other systems)*

Python 3 handles arbitrarily large integers, but in some applications or libraries, extremely large numbers may cause overflows or unexpected behavior.
Port numbers beyond 65535 are **invalid** in networking terms, even if Python accepts them as integers.

---
