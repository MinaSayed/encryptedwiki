---
title: Introduction to cmd module
---

## An overview of the REPL loop concept:

Before you touch the `cmd` module, you must understand the REPL (Read–Eval–Print Loop).
Every interactive program—from your Python shell to a Linux terminal—runs on this fundamental cycle:

* **Read**: The program pauses and waits for you to type something.
* **Eval (Evaluate)**: The program takes that text and determines what it means.
* **Print**: The program displays the result.
* **Loop**: The program returns to Step 1 and waits again.

In Python’s `cmd` module, this loop is handled by a method called `cmdloop()`.
Without this loop, a program runs once and terminates. With it, you create an interactive environment.

---

**For example:**

If you want to write a simple or primitive Python interactive shell following the REPL concept,
you can use a `while` loop combined with `try`–`except` blocks.

```python
while True:
    try:
        user_input = input("ENTER COMMAND > ")

        if user_input.strip().lower() == "hello":
            print("Hi, there!")
        elif user_input.strip().lower() == "status":
            print("System is running.")
        elif user_input.strip().lower() == "exit":
            break
        else:
            print("Unknown command")

    except KeyboardInterrupt:
        print("\nShutdown signaled")
        break
```

---

In the previous example, the line that asks the user to enter or provide input represents the **READ phase**.
In this phase, the computer only reads whatever the user enters.

```python
user_input = input("ENTER COMMAND > ")
```

---

In the **EVAL phase**, the computer evaluates the user input.
It takes whatever the user enters, interprets its meaning, and checks whether it matches the program’s logic.
The following lines represent the **EVAL phase**:

```python
if user_input.strip().lower() == "hello":
elif user_input.strip().lower() == "status":
elif user_input.strip().lower() == "exit":
```

---

In the **PRINT phase**, the program outputs a response based on the evaluated input.
The following lines represent the **PRINT phase**:

```python
print("Hi, there!")
print("System is running.")
print("Unknown command")
print("\nShutdown signaled")
```

---

In the **LOOP phase**, the program returns to the beginning and waits for new input.
This phase is represented by the infinite loop itself:

```python
while True:
```

As long as no `break` statement is triggered, the program continues cycling through **READ → EVAL → PRINT → LOOP**,
which is exactly what defines a REPL-based interactive program.

## Definition of cmd module:


Here’s your explanation corrected for grammar, spelling, and clarity, without changing your words, and filling in missing details where necessary:

---

## How to use cmd module:

### Importing the cmd module:

First, if we want to use all the contents of the cmd module, we have to import it first to be able to access its content:

```python
import cmd
```

### Creating a custom class child that inherits from the parent class (`cmd.Cmd`):

After importing the cmd module, there is a class called `cmd.Cmd`. This class is a very important class inside the cmd module.
It knows how to loop, how to handle help menus, and how to find commands.

So, we create a child class from the parent class and inherit from the parent all the powers it has.
After creating the child class that inherits from the parent class, you can define the specific commands you want.

The general syntax is:

```python
import cmd

class subclass_name(cmd.Cmd):
    # write the commands here
```

When you write `class MyShell(cmd.Cmd):`, you are telling Python:
*"Give MyShell all the powers of cmd.Cmd, but I will add my own flavor to it."*

### Defining all the methods or commands inside the subclass:
#### Defining the command dispatcher:
Defining all the methods or commands inside the subclass means you are telling your program what actions it should take
when a user types a specific command in your shell. Each command is written as a method inside your custom class
that inherits from cmd.Cmd.

The naming convention is important: each command method must start with do_ followed by the name of the command.
For example, if you want the command to be hello, you define a method called do_hello.


Inside the method, you write the instructions for what should happen when the user types that command.
The method can also take an argument, usually called arg, which holds any extra text the user types after the command.
This allows your commands to accept input dynamically, so they are not limited to fixed actions.



The `cmd` module always gives your command **one raw string** as the argument and does not split it automatically.
The reason is that a space character does **not always mean a new argument**.
Sometimes a space is just part of the same text.The module cannot guess the user’s intention.

Think of the cmd module as a very polite receptionist. It listens carefully,
writes down exactly what you said, and refuses to guess your intentions.

When you type a command in a cmd.Cmd shell, everything after the command name is handed to your method
as one raw string (arg). No splitting. No interpretation. Just the text.

**For example:**

If the user writes:

```
note This is my long note
```

What the command really needs is this single value:

```
arg = "This is my long note"
```

If `cmd` split the argument automatically, it would become:

```
["This", "is", "my", "long", "note"]
```
Now the program has a problem.Were those five separate arguments?
Or was the user trying to write one note containing spaces?

The cmd module cannot know that safely.It cannot guess the intention of the user.

If the tool automatically treats spaces as separators, it is making an assumption about what the user meant.
The `cmd` module avoids this mistake by passing the input as a raw string and letting the command itself decide
 how to interpret it. That way, the program stays correct instead of guessing.

So the program passing yhe raw string:

```python
"This is a long note"
```
it avoids making a wrong assumption. The command author—not the framework—decides how to interpret the text.

This design gives you freedom:

-You can treat the whole string as one value (notes, messages, SQL queries, search text).

-You can split it yourself if your command truly expects multiple arguments.

-You can implement quoting rules, flags, or custom parsing later.



**For example:**

```python
import cmd

class SimpleShell(cmd.Cmd):
    def do_hello(self, arg):
        print("Hi from the module!")

if __name__ == "__main__":
    SimpleShell().cmdloop()
```

**Explanation of the example:**

* `do_hello` is a command that the user can type in the shell.
* `arg` contains any text the user types after the command.
* `cmdloop()` starts the interactive loop where the user can type commands repeatedly.

---

**Example-1:**
```python
import cmd

class SimpleShell(cmd.Cmd):
    def do_greet(self, arg):
        if arg:
            print(f"Hello, {arg}")
        else:
            print("Hello, stranger")
if __name__ == "__main__":
    SimpleShell().cmdloop()
```

**Example-2:**
```python
class StatusShell(cmd.Cmd):
   def do_status(self, arg):
       if arg:
           print("Your status is {arg}")
       else:
           print("Your status is missing!")

if __name__ == "__main__"
   StatusShell().cmdloop()
```

Here’s the same idea, cleaned up and explained plainly, without changing the meaning—just tightening the logic and fixing one small naming slip.

When a user types a command like `status online` into a program built with Python’s `cmd` module, the module first looks at the **first word**. That first word is treated as the command name. In this case, the command is `status`.

The `cmd` module then checks whether a method named `do_status` exists on your command class. If that method exists, the module knows that `status` is a valid command and that `do_status` is the method that should handle it.

Everything **after** the command name is treated as one raw string. Here, the remaining text is `online`, so the module passes that exact string as the argument. As a result, it calls:

`do_status(self, "online")`

The important detail is that the argument is not split for you. Even if there were multiple words after `status`, they would still arrive as a single string.

So when a user types `status online`, the process is simple:
the module identifies `status` as the command, identifies `online` as the argument string, and calls `do_status(self, "online")`.

If the user types only `status` with no extra text, the module still calls the same method, but this time it passes an empty string:

`do_status(self, "")`

An empty string is still a string, which means your command method is always called with **exactly one argument**, whether the user typed extra text or not. This design keeps command handling predictable and puts you, not the framework, in control of how arguments are interpreted.
